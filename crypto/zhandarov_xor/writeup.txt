Итак, у нас имеются код на Python и какие-то цифры, именуемые cipher. Для начала разберём имеющийся алгоритм.
Сначала строка на входе дополняется пробелом и собственным началом так, чтобы её длина была кратна размеру блока (в нашем случае - 4). Затем производится блочная перестановка: каждый блок записывается задом наперёд. После этого генерируется случайное число от 0 до 9 (назовём его “вектор инициализации”). Первый символ строки, полученной после перестановки, xor’ится с вектором инициализации, каждый последующий - с суммой ASCII-кода предыдущего символа и остатком от деления предыдущего ключа на 10. В результате получаем последовательность цифр, которая и является нашим шифротекстом.
Для расшифрования нам нужно произвести все операции в обратном порядке. Мы знаем, что форма флага начинается с CTF{ - это соответствует размеру блока, равному 4. Значит, после перестановки блок выглядит как {FTC. Зная это, мы можем подобрать вектор инициализации простым перебором от 0 до 9 - xor’им первое число с вектором инициализации, пока не получим ‘{‘. Далее разворачиваем алгоритм в обратном порядке: xor’им шифр с ключом, записываем блоки задом наперёд, убираем дополнение, получаем флаг.

Флаг: CTF{xorisstrongbutnot}