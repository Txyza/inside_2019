# Weak link
ctf{The_Weakest_Link_found!}

Проще всего тем, у кого есть мозг, кто когда-нибудь проходил теорию графов в контексте программирования. Тут пути 2, либо смотреть в самое начало, где увидеть Vertex и Queue. Что в сумме в 90% случаев даёт поиск в глубину. Второй путь - найти функцию BFS. (Поиск в ширину англ. breadth-first search)

Но это слишком сложна для [95%](https://lurkmore.to/95%25) людей. Поэтому начну сначала.

Исследуем код. Есть 2 структуры, из названия понятно, что это. vertex - вершина (графа) и queue - очередь.
Начну с первой. Массив `nei` непонятного назначения, к нему размер. После - строки `name` и `message`. И некий уровень.
Структура очереди должна быть знакома всем. Первый элемент - указатель на вершину (графа), второй - указатель на другой элемент очереди. Соответственно имеем односвязный список. Указатель `next` как бы намекает на то, в каком порядке хранится очередь.

Затем объявлен массив указателей вершин (графа), который зовётся `graph`. Что окончательно даёт понять, о чём пойдёт речь далее. К нему, опять же, размер.

После обявлены указатели на очередь, которые зовутся `tail` и `head`. Можно предположить, что указывают они на начало и конец.

Функции `push` и `pop` кладут вершину в очередь и извлекают из неё соответственно. `reset` - отчищает очередь.

Затем идут функции для работы с графами. `create_vertex` действительно создаёт вершину и инициализирует поля, после чего возращает. `add_vertex` является обёрткой к `create_vertex`, и сохранением созданной вершины в графе занимается она. `remove_vertex` действительно удаляет вершину.
`add_neighbor` - название намекает на то, что `nei` - описание "соседей". Суть её работы в том, чтобы добавить указатель на вершину-соседа в "пулл соседей". `add_edge` - её обёртка, чтобы обе вершины знали о том, что они соседи.

`find_vertex` - поиск вершины по аргументу `name`. Без комментариев.

`init`/`deinit` занимаются инициализацией и "финализацией" соответственно. Первый обнуляет параметры, второй - высвобождает память.

`clear_graph` - обнуляет уровни вершин.

И наконец, мы подходим хоть к чему-то интересному. `print_graph`. Для всех вершин графа выводит: имя, имена соседей, если уровень меньше 0, то сообщение и, собственно, уровень.

`print_menu` - тут всё понятно.

И самое интересное. `BFS`. Тупое описание примерно сл.:
Обнулить уровни всех вершин.
В стек положить  первый узел графа.
Пока очередь не пуста:
    Извлечь из очереди очередной элемент.
    Пройтись по всем его соседям:
        если уровень соседа равен нулю, то добавить его в очередь.
        иначе увеличить flag.
    Если flag больше единицы, то установить уровень в -1 и отчистить очередь.
    иначе присвоить вершине очередной номер, а flag сбросить в 0.

Тут выясняются условия, при которых уровень вершины может стать равным -1: Если у вершины более одного соседа имеют уровень выше 0. Легко понять, что уровень выше 0 у вершин, которые алгоритм уже обработал. Так что можно перефразировать: Если у вершины более одного соседа, которым уровень уже был присвоен.
Не сложно понять, что при присвоении -1, алгоритм находит цикл из вершин графа и прерывается. т.е. `message` выведется только у той вершины, которая является дальней в ближайшем цикле к нулевой вершине. (разумеется это нужно проверить экспериментально, и тут уже можно будет видеть флаг).

Но для полноты картины скажу, что `main` осуществляет взаимодействие с пользователем.
